     1                                  %include "./lib64.asm"
     1                              <1>          section .text     ; ������� ����
     2                              <1> IntToStr64: 
     3 00000000 57                  <1>          push   rdi
     4 00000001 53                  <1>          push   rbx
     5 00000002 52                  <1>          push   rdx
     6 00000003 51                  <1>          push   rcx
     7 00000004 56                  <1> 		 push   rsi
     8 00000005 C60600              <1> 		 mov    byte[rsi],0 ; �� ����� �����
     9 00000008 83F800              <1>          cmp    eax,0
    10 0000000B 7D05                <1>          jge    .l1
    11 0000000D F7D8                <1>          neg    eax
    12 0000000F C6062D              <1>          mov    byte[rsi],'-'
    13 00000012 C646060A            <1> .l1      mov    byte[rsi+6],10
    14 00000016 BF05000000          <1>          mov    rdi,5
    15 0000001B 66BB0A00            <1>          mov    bx,10
    16 0000001F 6699                <1> .again:  cwd           ; ��������� ����� �� ��������
    17 00000021 66F7F3              <1>          div    bx     ; ����� ��������� �� 10
    18 00000024 80C230              <1>          add    dl,30h ; �������� �� ������� ��� �����
    19 00000027 88143E              <1>          mov    [rsi+rdi],dl ; ����� ������ � ������
    20 0000002A 48FFCF              <1>          dec    rdi    ; ��������� ��������� ��  
    21                              <1>                        ; ���������� �������
    22 0000002D 6683F800            <1>          cmp    ax, 0  ; ������������� ��� �����?
    23 00000031 75EC                <1>          jne    .again
    24 00000033 B906000000          <1>          mov    rcx, 6
    25 00000038 4829F9              <1>          sub    rcx, rdi ; ����� ����������+����
    26 0000003B 4889C8              <1> 		 mov    rax,rcx
    27 0000003E 48FFC0              <1> 		 inc    rax    ; ����� ����������+OA
    28 00000041 48FFC6              <1>          inc    rsi    ; ���������� ����
    29 00000044 56                  <1> 		 push   rsi
    30 00000045 488D343E            <1>          lea    rsi,[rsi+rdi] ; ������ ����������
    31 00000049 5F                  <1> 		 pop    rdi
    32 0000004A F3A4                <1>          rep movsb
    33 0000004C 5E                  <1>          pop    rsi  
    34 0000004D 59                  <1>          pop    rcx
    35 0000004E 5A                  <1>          pop    rdx
    36 0000004F 5B                  <1>          pop    rbx
    37 00000050 5F                  <1>          pop    rdi
    38 00000051 C3                  <1>          ret
    39                              <1> StrToInt64:
    40 00000052 57                  <1>          push   rdi
    41 00000053 B739                <1>          mov    bh, '9'
    42 00000055 B330                <1>          mov    bl, '0'
    43 00000057 56                  <1>          push   rsi     ; ��������� ����� �������� ������
    44 00000058 803E2D              <1>          cmp    byte[rsi], '-'
    45 0000005B 7503                <1>          jne    .prod
    46 0000005D 48FFC6              <1>          inc    rsi     ; ���������� ����
    47 00000060 FC                  <1> .prod    cld
    48 00000061 6631FF              <1>          xor    di, di  ; �������� ������� �����
    49 00000064 AC                  <1> .cycle:  lodsb          ; ��������� ������ (�����)
    50 00000065 3C0A                <1>          cmp    al, 10  ; ���� 10, �� �� �����
    51 00000067 741F                <1>          je     .Return
    52 00000069 38D8                <1>          cmp    al, bl  ; ���������� � ����� ����
    53 0000006B 722F                <1>          jb     .Error  ; "����" � ������
    54 0000006D 38F8                <1>          cmp    al, bh  ; ���������� � ����� ������ 
    55 0000006F 772B                <1>          ja     .Error  ; "����" � ������
    56 00000071 2C30                <1>          sub    al, 30h ; �������� ����� �� �������
    57 00000073 6698                <1>          cbw            ; ��������� �� �����
    58 00000075 6650                <1>          push   ax      ; ��������� � �����
    59 00000077 66B80A00            <1>          mov    ax, 10  ; ������� 10 � AX
    60 0000007B 66F7E7              <1>          mul    di      ; ��������, ��������� � DX:AX
    61 0000007E 665F                <1>          pop    di      ; � DI � ��������� �����
    62 00000080 6601F8              <1>          add    ax, di
    63 00000083 6689C7              <1>          mov    di, ax  ; � DI � ����������� �����        
    64 00000086 EBDC                <1>          jmp    .cycle
    65 00000088 5E                  <1> .Return: pop    rsi
    66 00000089 BB00000000          <1>          mov    rbx, 0
    67 0000008E 803E2D              <1>          cmp    byte[rsi], '-'
    68 00000091 7503                <1>          jne    .J
    69 00000093 66F7DF              <1>          neg    di
    70 00000096 6689F8              <1> .J       mov    ax, di
    71 00000099 98                  <1>          cwde
    72 0000009A EB0B                <1>          jmp    .R
    73 0000009C 5E                  <1> .Error:  pop    rsi
    74 0000009D B800000000          <1>          mov    rax, 0
    75 000000A2 BB01000000          <1>          mov    rbx, 1
    76 000000A7 5F                  <1> .R       pop    rdi
    77 000000A8 C3                  <1>          ret
     2                                  
     3                                  %macro write_string 2
     4                                      ; вывод
     5                                      ; 1 - адрес строки, 2 - длина строки
     6                                      mov     rax, 1          ; системная функция 1 (write)
     7                                      mov     rdi, 1          ; дескриптор файла stdout=1
     8                                      mov     rsi, %1         ; адрес выводимой строки
     9                                      mov     rdx, %2         ; длина строки
    10                                      syscall                 ; вызов системной функции
    11                                  %endmacro
    12                                  
    13                                  %macro read_string 2
    14                                      ; ввод
    15                                      ; 1 - буфер ввода, 2 - длина буфера ввода
    16                                      mov     rax, 0          ; системная функция 0 (read)
    17                                      mov     rdi, 0          ; дескриптор файла stdin=0
    18                                      mov     rsi, %1         ; адрес вводимой строки
    19                                      mov     rdx, %2         ; длина строки
    20                                      syscall                 ; вызов системной функции
    21                                  %endmacro
    22                                  
    23                                  %macro StrToInt 1
    24                                      ; перевод string в integer
    25                                      ; rsi должен содержать адрес строки для преобразования
    26                                      call    StrToInt64          ; вызов процедуры
    27                                      cmp     rbx, 0              ; сравнение кода возврата
    28                                      jne     StrToInt64.Error    ; обработка ошибки
    29                                      mov     %1, eax            
    30                                  %endmacro
    31                                  
    32                                  %macro IntToStr 2
    33                                      ; перевод integer в string
    34                                      mov     rsi, %2
    35                                      mov     eax, %1             ; получение числа из памяти
    36                                      cwde
    37                                      call    IntToStr64          ; вызов процедуры
    38                                      cmp     rbx, 0              ; сравнение кода возврата
    39                                      jne     StrToInt64.Error    ; обработка ошибки         
    40                                  %endmacro
    41                                  
    42                                      section .data           ; сегмент инициализированных переменных
    43 00000000 456E74657220746865-     InputMsg    db      "Enter the martix 5x5:", 10
    43 00000009 206D61727469782035-
    43 00000012 78353A0A           
    44                                  lenInput    equ     $-InputMsg
    45 00000016 596F7572206D617472-     OutputMsg   db      "Your matrix after conversion:", 10
    45 0000001F 697820616674657220-
    45 00000028 636F6E76657273696F-
    45 00000031 6E3A0A             
    46                                  lenOutput   equ     $-OutputMsg
    47 00000034 09                      tab         db      9
    48 00000035 0A                      newLine     db      10
    49                                  
    50                                      section .bss            ; сегмент неинициализированных переменных
    51 00000000 <res 0000000A>          InBuf   resb    10          ; буфер для вводимой строки
    52                                  lenIn   equ     $-InBuf     ; длина буфера для вводимой строки
    53 0000000A <res 0000000A>          OutBuf  resb    10
    54                                  lenOut  equ     $-OutBuf
    55 00000014 <res 00000064>          matrix  resd    25          ; 5 * 5 = 25 => резервируем 25 элементов для матрицы
    56 00000078 <res 00000004>          sum     resd    1           
    57                                  
    58                                      section .text           ; сегмент кода
    59                                      global _start
    60                                  
    61                                  _start:
    62                                  
    63                                      write_string InputMsg, lenInput
    63                              <1> 
    63                              <1> 
    63 000000A9 B801000000          <1>  mov rax, 1
    63 000000AE BF01000000          <1>  mov rdi, 1
    63 000000B3 48BE-               <1>  mov rsi, %1
    63 000000B5 [0000000000000000]  <1>
    63 000000BD BA16000000          <1>  mov rdx, %2
    63 000000C2 0F05                <1>  syscall
    64                                  
    65                                      ; ввод матрицы
    66 000000C4 B900000000                  mov rcx, 0          ; обнуляем счётчик внешнего цикла
    67                                      cycle_read_matrix:
    68 000000C9 51                              push rcx        ; помещаем rcx в стек 
    69                                  
    70 000000CA 4883EC10                        sub rsp, 16     ; выделяем память для буфера перевода строк в числа и счетчик (6 - буфер, 2 -счетчик)
    71 000000CE 4883EC40                        sub rsp, 64     ; выделяем память для буфера ввода 
    72                                          
    73                                          read_string rsp, 64
    73                              <1> 
    73                              <1> 
    73 000000D2 B800000000          <1>  mov rax, 0
    73 000000D7 BF00000000          <1>  mov rdi, 0
    73 000000DC 4889E6              <1>  mov rsi, %1
    73 000000DF BA40000000          <1>  mov rdx, %2
    73 000000E4 0F05                <1>  syscall
    74                                  
    75 000000E6 B900000000                      mov rcx, 0              ; rcx - индекс символа в строке, введенной пользователем
    76 000000EB 488B442450                      mov rax, [rsp + 80]     ; поместим в rax номер текущей строки (80 т.к. 64+16 = 80)
    77 000000F0 486BC005                        imul rax, 5             ; вычислим индекс элемента массива для записи при сквозной нумерации
    78 000000F4 6689442446                      mov [rsp + 70], ax      ; [rsp + 70] - индекс элемента массива для записи
    79 000000F9 B800000000                      mov rax, 0              ; rax - счётчик символов в буфере для перевода строк в числа
    80                                          while:
    81 000000FE 803C0C20                            cmp byte [rsp + rcx], 32        ; сравниваем символ в строке с пробелом
    82 00000102 7502                                jne not_space                   ; если не пробел, прыгаем на not_space
    83 00000104 EB14                                jmp end_of_number               ; иначе прыгаем на end_of_number
    84                                              not_space:
    85 00000106 803C0C0A                                cmp byte [rsp + rcx], 10    ; сравниваем символ в строке с enter
    86 0000010A 7502                                    jne not_enter               ; если не enter, прыгаем на not_enter
    87 0000010C EB0C                                    jmp end_of_number           ; иначе прыгаем на end_of_number
    88                                              not_enter:
    89                                                  ; запоминаем символ в буфере
    90 0000010E 8A1C0C                                  mov bl, [rsp + rcx]         
    91 00000111 885C0440                                mov [rsp + 64 + rax], bl    ; перенос символа из исходной строки в буфер для перевода
    92 00000115 48FFC0                                  inc rax                     ; увеличиваем счётчик
    93 00000118 EB3D                                    jmp continue                ; прыгаем на continue
    94                                              end_of_number:
    95 0000011A B30A                                    mov bl, 10                  
    96 0000011C 885C0440                                mov [rsp + 64 + rax], bl    ; добавляем символ \n в буфер для перевода 
    97 00000120 488D742440                              lea rsi, [rsp + 64]         ; помещаем в rsi адрес буфера для перевода
    98 00000125 BB00000000                              mov rbx, 0                  ; чтобы StrToInt нормально работал
    99 0000012A 51                                      push rcx                    ; помещаем rcx в стек, потому что регистров не хватает, создатели ассемблера не подумали
   100 0000012B 488B4C244E                              mov rcx, [rsp + 78]         ; помещаем в rcx индекс элемента массива для записи
   101                                                  StrToInt [matrix + rcx*4]   ; преобразуем буфер в число и записываем в матрицу
   101                              <1> 
   101                              <1> 
   101 00000130 E81DFFFFFF          <1>  call StrToInt64
   101 00000135 4883FB00            <1>  cmp rbx, 0
   101 00000139 0F855DFFFFFF        <1>  jne StrToInt64.Error
   101 0000013F 89048D[14000000]    <1>  mov %1, eax
   102 00000146 66FF44244E                              inc word [rsp + 78]         ; переходим к следующему элементу матрицы
   103 0000014B 59                                      pop rcx                     ; вытаскиваем rcx из стека, потому что регистров не хватало и т.п....
   104 0000014C B800000000                              mov rax, 0                  ; обнуляем счётчик символов в буфере для перевода
   105 00000151 803C0C0A                                cmp byte [rsp + rcx], 10    ; сравниваем символ в строке с enter
   106 00000155 7405                                    je break_while              ; если enter, то выходим из цикла
   107                                              continue:
   108 00000157 48FFC1                                  inc rcx                     ; переходим к следующему символу в строке
   109 0000015A EBA2                                    jmp while                   ; переходим к следующей итерации цикла
   110                                              break_while:
   111                                          
   112 0000015C 4883C450                        add rsp, 80     ; вернем стек к изначальному состоянию
   113 00000160 59                              pop rcx         ; вытащим rcx из стека
   114 00000161 48FFC1                          inc rcx         ; увеличиваем счётчик строк на 1
   115 00000164 4883F905                        cmp rcx, 5      ; если строка < 5 по счету, то переходим к следующей итерации
   116 00000168 0F8C5BFFFFFF                    jl cycle_read_matrix
   117                                  
   118                                  
   119                                      ; вычисления
   120 0000016E B900000000                  mov rcx, 0              ; обнуляем счётчик внешнего цикла
   121                                      cycle_row:              ; внешний цикл для строк
   122 00000173 51                              push rcx            ; помещаем rcx в стек (номер текущей строки - 1)
   123 00000174 BB00000000                      mov rbx, 0          
   124 00000179 48891C25[78000000]              mov [sum], rbx      ; изначально сумма равна 0
   125 00000181 B905000000                      mov rcx, 5          ; количество итерации внешнего цикла равно 5
   126                                          cycle_col:                      ; внутренний цикл для столбцов
   127 00000186 51                                  push rcx                    ; помещаем rcx в стек (счётчик итераций)
   128 00000187 53                                  push rbx                    ; помещаем rbx в стек (индекс элемента в строке)
   129 00000188 488B5C2410                          mov rbx, [rsp + 16]         ; rbx = номер текущей строки - 1
   130 0000018D 486BDB05                            imul rbx, 5                 ; rbx = (номер текущей строки - 1) * 5, т.к. в строке 5 элементов
   131 00000191 48031C24                            add rbx, [rsp]              ; rbx = rbx + индекс элемента в строке
   132 00000195 8B049D[14000000]                    mov eax, [matrix + rbx*4]   ; eax = matrix[rbx], умножаем на 4, т.к. dword
   133 0000019C 5B                                  pop rbx                     ; вытаскиваем rbx из стека (индекс элемента в строке)
   134 0000019D 48FFC3                              inc rbx                     ; переходим к следующему элементу строки
   135 000001A0 59                                  pop rcx                     ; вытаскиваем rcx из стека (счётчик итераций)
   136 000001A1 83F800                              cmp eax, 0
   137 000001A4 7E0E                                jle cont
   138 000001A6 030425[78000000]                    add eax, [sum]              ; eax = eax + sum
   139 000001AD 890425[78000000]                    mov [sum], eax              ; sum = eax
   140                                              cont:
   141 000001B4 E2D0                                loop cycle_col              ; переходим к следующей итерации внутреннего цикла
   142 000001B6 8B0425[78000000]                mov eax, [sum]              ; eax = конечная сумма строки
   143 000001BD 89C2                            mov edx, eax                ; помещаем eax в edx
   144 000001BF C1EA10                          shr edx, 16                 ; сдвигаем edx на 2 байта, чтобы в dx лежали старшие разряды eax
   145 000001C2 59                              pop rcx                     ; вытаскиваем rcx из стека (номер текущей строки - 1)
   146 000001C3 4889CB                          mov rbx, rcx                ; rbx = номер текущей строки - 1
   147 000001C6 486BDB05                        imul rbx, 5                 ; rbx = (номер текущей строки - 1) * 5        
   148 000001CA 4801CB                          add rbx, rcx                ; rbx = индекс элемента матрицы, совпадающий с (5 - номер строки, в которой он находится)
   149 000001CD 89049D[14000000]                mov [matrix + rbx*4], eax   ; matrix[rbx] = сумма положительных чисел строки
   150 000001D4 BB00000000                      mov rbx, 0                  ; обнуляем rbx
   151 000001D9 48FFC1                          inc rcx                     ; увеличиваем счетчик итераций внешнего цикла
   152 000001DC 4883F905                        cmp rcx, 5                  ; сравниваем счётчик с 5
   153 000001E0 7C91                            jl cycle_row                ; если итераций меньше 5, прыгаем на cycle_row
   154                                  
   155                                  
   156                                      write_string OutputMsg, lenOutput
   156                              <1> 
   156                              <1> 
   156 000001E2 B801000000          <1>  mov rax, 1
   156 000001E7 BF01000000          <1>  mov rdi, 1
   156 000001EC 48BE-               <1>  mov rsi, %1
   156 000001EE [1600000000000000]  <1>
   156 000001F6 BA1E000000          <1>  mov rdx, %2
   156 000001FB 0F05                <1>  syscall
   157                                  
   158                                      ;вывод матрицы
   159 000001FD B900000000                  mov rcx, 0              ; обнулим счётчик внешнего цикла (rcx = i * 5, i = 0)
   160                                      cycle_print_matrix:     ; внешний цикл для строк
   161 00000202 51                              push rcx            ; помещаем rcx в стек
   162 00000203 B905000000                      mov rcx, 5          ; количество итераций внутреннего цикла равно 5
   163                                          cycle_print_array:                      ; внутренний цикл для столбцов
   164 00000208 51                                  push rcx                            ; помещаем rcx в стек, запоминаем номер итерации
   165 00000209 48F7D9                              neg rcx                             
   166 0000020C 4883C105                            add rcx, 5                         
   167 00000210 48034C2408                          add rcx, [rsp + 8]                  ; вычисляем индекс текущего элемента при сквозной нумерации (+8, т.к. до этого было 2 пуша)
   168                                              IntToStr [matrix + rcx*4], OutBuf   ; переводим элемент массива в строку и записываем в OutBuf
   168                              <1> 
   168 00000215 48BE-               <1>  mov rsi, %2
   168 00000217 [0A00000000000000]  <1>
   168 0000021F 8B048D[14000000]    <1>  mov eax, %1
   168 00000226 98                  <1>  cwde
   168 00000227 E8D4FDFFFF          <1>  call IntToStr64
   168 0000022C 4883FB00            <1>  cmp rbx, 0
   168 00000230 0F8566FEFFFF        <1>  jne StrToInt64.Error
   169 00000236 4889C3                              mov rbx, rax                        ; перекладываем длину строки в rbx, т.к. write_string работает с rax
   170 00000239 48FFCB                              dec rbx                             ; удаляем символ перевода строки из строки
   171                                              write_string OutBuf, rbx            ; выводим один элемент матрицы
   171                              <1> 
   171                              <1> 
   171 0000023C B801000000          <1>  mov rax, 1
   171 00000241 BF01000000          <1>  mov rdi, 1
   171 00000246 48BE-               <1>  mov rsi, %1
   171 00000248 [0A00000000000000]  <1>
   171 00000250 4889DA              <1>  mov rdx, %2
   171 00000253 0F05                <1>  syscall
   172 00000255 BB00000000                          mov rbx, 0                          ; обнуляем rbx
   173                                              write_string tab, 1                 ; дописываем \t к строке
   173                              <1> 
   173                              <1> 
   173 0000025A B801000000          <1>  mov rax, 1
   173 0000025F BF01000000          <1>  mov rdi, 1
   173 00000264 48BE-               <1>  mov rsi, %1
   173 00000266 [3400000000000000]  <1>
   173 0000026E BA01000000          <1>  mov rdx, %2
   173 00000273 0F05                <1>  syscall
   174 00000275 59                                  pop rcx                             ; вытаскиваем rcx из стека
   175 00000276 E290                                loop cycle_print_array
   176                                  
   177                                          write_string newLine, 1                 ; дописываем \n к строке
   177                              <1> 
   177                              <1> 
   177 00000278 B801000000          <1>  mov rax, 1
   177 0000027D BF01000000          <1>  mov rdi, 1
   177 00000282 48BE-               <1>  mov rsi, %1
   177 00000284 [3500000000000000]  <1>
   177 0000028C BA01000000          <1>  mov rdx, %2
   177 00000291 0F05                <1>  syscall
   178                                  
   179 00000293 59                              pop rcx                     ; вытаскиваем rcx из стека, rcx = количество пройденных строк * 5
   180 00000294 4883C105                        add rcx, 5                  ; увеличиваем счетчик (rcx = i * 5, i++)
   181 00000298 4883F919                        cmp rcx, 25                 ; сравниваем счетчик для нахождения конца матрицы (25 = 5 * 5, 5 - количество строк в матрице)
   182 0000029C 0F8C60FFFFFF                    jl cycle_print_matrix       ; если счетчик меньше количества строк, переходим к следующей итерации
   183                                      
   184                                      
   185 000002A2 B83C000000                  mov     rax, 60         ; системная функция 60 (exit)
   186 000002A7 4831FF                      xor     rdi, rdi        ; return code 0    
   187 000002AA 0F05                        syscall                 ; вызов системной функции
